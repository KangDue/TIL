"""
<Minimum Spanning Tree (최소 신장 트리)>
: 최소 연결 부분 그래프
- 간선의 수가 가장 적은
- n개의 정점을 가지는 그래프의 최소 간선의 수는 n - 1 개
- n - 1개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 됨.
- This is Spanning Tree
- 즉, 주어진 그래프에서 최소 간선으로 모든점 연결한 트리.
------------------------------------------------------------------------------------------------------------------------
Spanning Tree 의 특징
1.  DFS나 BFS를 활용하면 찾을 수 가 있다.
    (탐색 도중 사용된 간선만 모으면 만들기 가능)
2. 하나의 그래프에는 많은 신장트리가 존재할 수 있다.
    (모든점을 연결하는 여러 트리가 존재)
3. ST는 트리의 특수한 형태로 모든 정점들이 연결되어 있어야하고 사이클을 포함하면 안된다.(순환 x, 중복 x)
4. 따라서 정확히 그래프에 있는 n개의 정점을 n - 1개의 간선으로 연결한다.

사용사례
1. 통신 네트워크 구축
    (회사 내의 모든 전화기를 가장 적은 수의 케이블을 사용해 연결하고자 할 때)
...
------------------------------------------------------------------------------------------------------------------------
<MST>
MST = Spanning Tree중 사용된 간선들의 가중치 합이 최소인 트리
    (최단 경로와는 다름.) (트리는 경로가 아니다. 연결 상태임)
- 각 간선의 가중치가 동일하지 않을 때 단순히 가장 적은 간선을 사용한다고 해서
    최소 비용이 얻어지는것은 아니다.(1+1+1+1 vs 100+100)
- MST는 간선의 가중치를 고려하여 최소 비용의 Spanning Tree를 선택하는 것
- 즉, 네트워크(가중치를 간선에 할당한 그래프)에 있는 모든 정점들은 가장 적은 수의 간선과 비용으로 연결하는 것이다.

<MST의 특징>
1. 간선의 가중치의 합이 최소여야 한다. (핵심, 일반 ST와의 차이점)
2. n개의 정점을 가지는 그래프에 대해 반드시 (n-1)개의 간선만을 사용해야 한다.
3. 사이클이 포함되어서는 안된다.

<MST의 사용사례>
- 통신망, 도로망, 유통망등에서 길이, 구축비용, 전송 시간 등을 최소로 구축하려는 경우

<MST의 구현방법 1>
1. Kruskal MST 알고리즘(크루스칼)
: 탐욕적인 방법(greedy) 을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을
    최소비용으로 연결하는 최적 해답을 구하는 알고리즘

- MST가 1)최소 비용의 간선으로 구성됨 ,2) 사이클을 포함하지 않음
    위 조건에 근거하여 각 단계에서 사이클을 이루지않는 최소비용의 간선 선택
- 간선 선택을 기반으로 하는 알고리즘
- 이전 단계에서 만들어진 신장트리와는 상관없이 무조건 최소 간선만을 선택하는 방법

[과정]
- 1. 그래프의 간선들을 가중치의 오름차순으로 정렬
- 2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.(=이미 포함되어 있지 않은)
    - 즉, 가장 낮은 가중치를 먼저 선택
    - 사이클을 형성하는 간선을 제외
- 3. 해당 간선을 현재의 MST의 집합에 추가.

<MST의 구현방법 2>
2. Prim 알고리즘
: 시작 정점에서부터 출발하여 신장트리 집합을 단계적으로 확장 해나가는 방법
- 정점 선택을 기반으로 하는 알고리즘이다.
- 이전 단계에서 만들어진 신장트리를 확장하는 방법이다.

[과정]
- 1. 시작 단계에서는 시작 정점만이 MST(최소 비용 신장 트리) 집합에 포함된다.
- 2. 앞 단계에서 만들어진 MST 집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리를 확장한다.
    - 즉, 가장 낮은 가중치를 먼저 선택한다.
- 3. 위의 과정을 트리가 (n-1)개의 간선을 가질 때 까지 반복한다.


[시간 복잡도]
- union-find 알고리즘으로 (공통조상 찾기,병합 쉬움,사이클 확인)을 이용하면 Kruskal 알고리즘의 복잡도는
    간선을 정렬하는 시간에 좌우된다.
- 즉, 간선 e개를 효율적인 정렬알고리즘으로 정렬한다면 O(nlogn)되기도 한다. (더빠르거나 느려질 수 있다.)
- Prim 알고리즘의 시간 복잡도는 O(n**2)이므로
    - 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프(sparse graph)의 경우 크루스칼이 적합
    - 그래프 내에 간선이 많이 존재하는 밀집 그래프(Dense)의 경우는 Prim 알고리즘이 적합

"""
import sys
sys.stdin = open('input1.txt')
n, e = map(int,input().split())#노드 수, 간선 수
edges = []
pt = list(range(n+1)) #각자 자기자신을 부모노드로 초기화 (parent table) , union find 개념(자료구조)
for i in range(e): #각 간선이 (무방향 그래프일 때)
    x, y, z = map(int,input().split())
    print(pt)
    if pt[x] != pt[y]:#두 부모노드가 같으면 이미 연결되어 있다는 뜻, pass하면 됨
        small, large = (pt[x],pt[y]) if pt[x] < pt[y] else (pt[y],pt[x]) #st 더 작은 부모노드, de 큰 부모노드
        edges.append([x,y,z]) # MST 추가
        for j in range(1,n+1):# 더 작은쪽 값으로 업데이트
            if pt[j] == large and pt[j] > small:#union find 개념(자료구조)
                pt[j] = small # 같은 부모인 값도 같이 업데이트
print(edges)

for i in range(e): #각 간선이 (무방향 그래프일 때)
    x, y, z = map(int,input().split())
    print(pt)
    if pt[x] != pt[y]:#두 부모노드가 같으면 이미 연결되어 있다는 뜻, pass하면 됨
        small, large = (pt[x],pt[y]) if pt[x] < pt[y] else (pt[y],pt[x]) #st 더 작은 부모노드, de 큰 부모노드
        edges.append([x,y,z]) # MST 추가
        for j in range(1,n+1):# 더 작은쪽 값으로 업데이트
            if pt[j] == large and pt[j] > small:#union find 개념(자료구조)
                pt[j] = small # 같은 부모인 값도 같이 업데이트
print(edges)



