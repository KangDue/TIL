# 트리 (Tree)
## 1. <트리의 개념>
1. 비선형 구조이다.
2. 원소들간 1:n 관계를 가지는 자료구조(1과 같은 말)
2. 원소들 간에 계층관계를 가지는 계층형 자료구조(루트,조상,부모,자식,리프 등..)
3. 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무) 모양의 구조
 
<b> 트리는 비선형구조이고, 원소들간 1:n의 관계와 계층관계를 가지고,
상위 원소에서 하위 원소로 내려가면서 확장되는 나무 모양의 구조이다.</b>

### <잠깐! - 트리와 그래프의 차이>
- 그래프는 트리보다 폭 넓은 개념이다.
- 두개 노드 사이에 반드시 하나의 경로만 존재한다.
- 사이클이 존재하지 않는다.
- 방향성 (상위 노드 -> 하위 노드)<br>

#### <그래프의 특징> 
- 방향,무방향 가능 
- 순환,비순환,자기순환 
- 루트, 부모, 자식 등의 개념 x
- 네트워크 모델( 트리는 계층 모델 )
- 간선의 수(=제한 없음/ 트리 -> 정점의 수 -1)


## 2. <트리의 정의>
1. 한 개 이상의 노드로 이루어진 유한집합이다.
   1. 노드 중 최상위 노드를 루트(root)라 한다.
   2. 나머지 노드들은 n(>=0)개의 분리집합 T1~TN으로 분리 될 수 있다.
   3. 이들은 각각 하나의 트리(재귀적 정의)가 되며 루트의 부 트리(sub tree) 라 한다.
2. 용어
   1. 정점(node / vertex) = 트리를 구성 하는 각 요소
   2. 간선(edge) = 정점간의 연결 관계, 노드끼리 연결하는  선
   3. 자식(child) 노드 = 어떤 노드의 하위 계층 노드
   4. 부모(parent) 노드 = 어떤 노드의 상위 계층 노드
   5. 형제(sibling) 노드 = 같은 부모 노드의 자식 노드
   6. 뿌리(root) 노드 = tree의 최 상단 노드(시작 노드)
   7. 조상(ancestor) 노드 = 어떤 노드의 상위 계층 노드의 모음(root 까지)<br>
      (부모 노드의 부모 노드의 ... 모음)
   8. 자손(descendent) 노드 = 서브 트리에 있는 하위 레벨 노드<br>
   (자식노드의 자식노드의 ... 모음)
   9. 단말(leaf) 노드 = 자식 노드가 없는 끝 노드.
   10. 차수(degree) = 노드에 연결된 자식 노드의 수<br>
       (트리가 아닌 보통 그래프에서는 연결된 노드의 수 뿐만 아니라 다양한 degree가 존재)
   11. 높이
       1. 노드의 높이 = 루트에서 해당 노드까지 간선의 수(node의 level)<br>
          (root 의 높이는 0)
       2. 트리의 높이 = 트리에 있는 노드 높이 중 가장 큰 값

## 3. 이진트리
정의 : 
- 모든 노드들이 2개의 서브 트리를 갖는 특별한 형태의 트리
(정확히는 2개 이하)
- 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리
  (왼쪽 자식 노드, 오른쪽 자식 노드)
- 레벨 i 에서 최대 노드의 최대 개수 = 2**i
- 높이 h인 이진 트리의 노드의 최소 개수는 h+1
- 최대 개수는 2**(h+1) - 1 로 이진수 처럼 생각하면 알기 쉽다.<br>
  (높이 h = 길이가 h인 이진수 ex= 000 의 최대값 111(2) = 7)

### 3-1. 포화 이진 트리(Full Binary Tree) (!=완전 이진 트리) 
- 모든 레벨의 노드가 포화상태
- 높이가 h일때 최대의 노드 개수인 2**(h+1) - 1 개 노드를 가진 트리
- 보통 루트를 1번으로 하여 2**(h+1) - 1 번 노드 번호를 가짐.

### 3-2. 완전 이진 트리
- 높이가 h이고, 노드 수가 n 일때 포화 이진트리의 노드번호 1번부터 n번까지 빈자리가 없는 이진트리<br>
  (단, h+1 <= n < 2**(h+1)-1)

### 3-3. 편향 이진 트리 (Skewed Binary Tree)
- 높이 h에 대한 최소개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 트리 <br>
  (linear한 자료와 다를바가 거의 없다. tree구조의 일반적인 이득이 없음)
- 왼쪽 편향 트리, 오른쪽 편향 트리가 있다.

## 4. 순회(traveral)
뜻: 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말한다.<br>
트리는 비 선형 구조이기 때문에 선형 구조에서와 같이 선-후 연결 관계를 알 수 없다.

아래는 기본적인 순회 방법이다.<br>
순회순서의 기준은 자기 자신(root)으로 한다.
- 1. 전위 순회(preorder traversal)
   = ROOT - LEFT - RIGHT 
- 2. 중위 순회(inorder traversal)
   = LEFT - ROOT - CHILD
- 3. 후위 순회(postorder traversal)
   = LEFT - RIGHT - ROOT

위의 각각의 순회는 각 노드로 이동후 살필때 자기 자신이
root , left, right인지 확인하고 아니면 계속 더 아래로 내려간다.
그러다가 말단 노드에 도달하면 그때부터 back 하면서 출력한다.
그래서 재귀 함수의 형태로 아주 간단하게 표현된다.

## 5. 배열을 이용한 이진트리의 표현
노드의 개수가 N개 일 때 (1번~N번)
(0~N-1번으로 해도 되지만, 헷갈림 방지)
- 배열의 크기 정하는 Tip 
  - 2**i <= n < 2**(i+1) 이면 트리의 높이는 h
  - h일때 최대 노드의 개수는 2**(h+1)-1
  - int('1'*h,2) - 1 로 표현도 가능

1. 빈 배열을 만든다 [0]*(n+1) 
2. 노드 번호가 i인 노드의 부모노드 =  i//2 번 노드.
3. 노드 번호가 i인 노드의 왼쪽 자식노드 = 2*i번 노드 
4. 노드 번호가 i인 노드의 오른쪽 자식노드 = 2*i + 1 번 노드
5. 왼쪽 편향 이진트리는 1,2,4,8 ... 번호를 가짐
6. 오른쪽 편향 이진트리는 1,3,7,15,... 번호를 가짐

### 배열을 이용한 이진트리 표현의 단점
- 편향 이진트리의 경우 사용하지 않는 배열 원소에 대해 메모리 공간 낭비 발생
- 트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우 배열의 크기 변경이 어려워 비 효율적
- 이러한 단점은 연결리스트를 이용해서 극복이 가능하다.
- 코드는 간략하게 아래와 같다.
```python
root = None
class Tree:
    def __init__(self, value, left=None, right=None):
        self.left = left
        self.right = right
        self.value = value
        
    def __str__(self):
        return self.value
```
## 6. 수식 트리(수식 이진 트리)
- 연산자와 피연산자로 이루어진 계산을 위한 수식 트리
- 연산자는 루트 노드 이거나 각 내부노드(=internal node, 가지에서 부모노드)이다.
- 피 연산자는 모두 말단(leaf, 단말=terminal)노드이다.
1. 중위 순회 = 우리가 평소 쓰는 식 모양(왼쪽 피연산자, 연산자, 오른쪽 피연산자)
2. 후위 순회 = 일반적으로 컴퓨터가 계산하는 방식(왼쪽 피연산자, 오른쪽 피연산자, 연산자)
3. 전위 순회 = (연산자, 왼쪽 피연산자, 오른쪽 피연산자)

## 7. 이진 탐색 트리
- 탐색 작업을 효율적으로 하기위한 자료구조
- 모든 원소는 중복 없이 유일한 key를 가진다.
- key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
- 각각의 서브트리도 이진 탐색 트리이다.
- 중위 순회 하면 오름차순 정렬된 값 얻을 수 있다. 
- 아래 직접 이진탐색트리를 구현해보자 (quick sort 응용)
- 탐색, 삽입, 삭제에는 중위순회를 활용할 수 있을 것이다.
```python
a = [5,4,16,7,3,9,1]
class BST:
    def __init__(self, value, left = None, right = None):
        self.value = value
        self.left = left
        self.right = right
    def __str__(self): #객체의 정보
        return str(self.value)
    def __repr__(self): #리스트 프린트시 객체 자체 meta 정보
        return str(self.value)

a = [BST(i) for i in a]

def make_tree(x):#중복값은 없다.
    if len(x) == 1:
        return  x[0]
    if not x:
        return None
    pivot = x[len(x)//2]
    left,right = [],[]
    for i in x:
        if i.value < pivot.value:
            left.append(i)
        elif i.value > pivot.value:
            right.append(i)
    pivot.left = make_tree(left)
    pivot.right = make_tree(right)
    return pivot
root = make_tree(a)

def inorder(x):
    if x.left:
        inorder(x.left)
    print(x)
    if x.right:
        inorder(x.right)

inorder(root)

```
- 이진탐색 트리의 성능
  - 탐색, 삽입, 삭제시 시간복잡도 = 트리의 높이 O(h) - 최선, 빅 오메가
  - 평균의 경우 (이진 트리가 균형적으로 생성된 경우) O(log(n)) - 최악, 빅 오
  - 최악의 경우 (skewed -> O(n), 순차 탐색과 같음.) - 평균 , 빅 세타 

## 참고 8. 힙(heap)
- 완전 이진트리에 있는 노드 중에서 키값이 가장 큰 노드나 작은 노드를 찾기위해서 만든 자료구조
- 최대 힙 = 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
- 최소 힙 = 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리

- 루트 노드의 원소만 삭제 가능. (삭제시 반환)
- 삽입하면서 부모노드와 크기를 비교해가며 교체함.
- 기본적으로 푸시, 팝 기능이 있다.
<hr>

# 컴퓨팅 사고력
Hard logic(논리) vs Soft logic(직감)
#### 직관
- 논리적인 느낌을 주고, 빠르지만 정확하지 않다.
- 착각을 일으키고, 일상에서 유용하다.
- 강한 착각을 일으킨다.
#### 논리
- 프로그래밍은 논리학에 기반한 표현으로 이를 이해라려면 논리를 알아햐한다.
- 직관만으로 알고리즘을 이해하기 어려움.

명제: p 이면 q이다.
역: q이면 p이다. 
이: not p 면 not q 다.
대우: not q면 not p 다.

<대우 이해하기>
if A: B
if not B: not A

#### 부호의 우선순위 와 명제의 분류
1. ㄱ > OR = ㄱ은 not 연산자로 파이썬에선 ~ 로 나타냄
2. AND > -> = & 연산자가  조건 (~ 이면 ~) 보다 우선
3. 마지막으로 <-> = 필요 충분 조건 (if and only if, bi condition)
- 항진명제 : 진리값이 항상 참
- 모순명제 : 진리값이 항상 거짓
- 사건명제 : 항진명제도 모순명제도 아닌 명제
- 조건명제 : p(원인) -> q(결과) = p이면 q 이다.<br>
  (= not p OR q = not( p and not q))
  (즉 q가 참이면 명제가 참이된다. = q가 항진명제면 자명한 증명,Trivial proof 라 한다.)
  (또는 p가 거짓이면 참이된다. = p가 모순명제면 어리석은 증명,VACUOUS proof)
- 쌍조건 명제 = <-> p면 q고, q면 p다 (두 명제가 모두 조건이며 결론인 명제)
  (= (p->q) and (q -> p))

#### 진리표를 만드는 순서.
ex) p ^ (q -> ~p) 가 있다 치면
p, q, ~p, q -> ~p, p ^ (q -> ~p) 순으로
각 명제 p,q에 대해서 T,F의 경우의 수에 대하여
나머지를 채워 넣으면 된다.

#### 증명
- 증명은 정확한 명제식으로 표현할 수 있어야 한다.
- 보통은 정확한 명제식으로 안쓰는데, 바꿀 수 있음
- 보통 증명에 대한 오해는 p -> q 와 q -> p를 혼동하는데서 시작

1. 귀납법 = P(1)이 참이고 P(n) -> P(n+1) 이 참이면 모든 자연수에 대해 참
   (= 주제선정 -> 관찰 -> 유형 발견(규칙) -> 임시결론(이론))
- 여기서 문제! P(n)이 진짜로 참일 필요 없이 P(n) - > P(n+1)이 참임을 보이는게 귀납법이다.

2. 연역법 (어떤 명제로 부터 추론 규칙에 따라 결론을 이끌어 내는것, ex)삼단 논법)
   (= 가설설정 -> 조작화 -> 관찰/경험 -> 검증)

#### 명제식
1. 명제식은 드모르간의 법칙이나 진리표를 활용해 식을 간소화 할 수 있다.
not(a and b) = (not a) OR (not b)
2. 교환법칙, 결합법칙이 성립한다( And, Or에 대해)
A OR (B AND C) = (A OR B) AND (A OR C)
괄호안에 있으면 +, - / 괄호 밖에 있으면 * 느낌.
3. 뒤집은 A는 임의의 ~에 대해(모두 그렇다.)
4. 좌우반대 E는 어떤 ~에 대해(존재 한다.)

<hr>

# 집합과 조합론, 기초 수식

1. B가 A의 부분집합이다. 를 증명
- B에 포함되는 임으의 원소 x 를 가정
- B의 원소 첫번째, 2번째 ,n번째 원소가 A의 원소인지 귀납적으로 증명
- 모두 포함되면 B는 A의 부분집합

## 1. 조합 ( nCr 또는 () 길다란 괄호 위아래 n r을 배치해 나타냄)
이 값은 파스칼 삼각형의 값들로 표현될 수 있다.

귀류법 - 어떤 명제가 참임을 증명하려 할 때 그 명제의 결론을 부정함으로써
가정 또는 공리의 모순을 보여 간접적으로 그 결론의 성립을 증명하는 방법

## 2. 기초수식
- 우리 알고리즘의 시간복잡도를 나타내 보자
- T(n) 은 한 함수의 호출을 의미한다
- T()가 아닌 부분은 연산의 횟수이다.
- T(n) = T(n-1) + 1 이고 T(0) = 1이면 함수의 호출은 n번이 이루어지며 1*n을 하면 n으로 시간복잡도는 O(n) 이다.
- T(n/2) = log n 번 호출,T(1) = 1 (2**x = n 에서 x가 반복 횟수임)
- 상수항이 없으면 호출부분도 계산해 줘야한다.

<hr>

## 동적 프로그래밍
- 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과값을 저장해두고 불러쓰는 방법이다.(Memoization)
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장 가능한 메모리가 필요
- 결과 값을 순서를 정해서 계산할 수도 있다.(DP)

## 시간 복잡도 
f(n)은 실제 걸리는 시간. (아래 표기들은 모두 계수 생략)
1. 빅 오(O(g(n))) = 점근적 상한 = 실행시간이 ~에 비례하는 
 n 이 증가함에 따라 n0 이상일 떼 g(n)이 항상 f(n) 보다 크다.
2. 빅 오메가 = 정근적 하한 n 이 증가할 때 g(n)이 항상 f(n)보다 작다.
3. 빅 세타 = 오, 오메가가 같을 때, g(n)과 동일한 증가율을 가진다.

## 엔디안(Endianness)
- 컴퓨터의 메모리와 같은 1차원의 공간에 여러개의 연속된 대상을 배열하는 방법
- HW 아키텍쳐마다 다르다
- 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산 할때 올바로 이해하지 않으면 오류 발생가능

1. 빅 엔디안(Big-endian)
- 보통 큰 단위가 앞으로 나옴. (네트워크)
2. 리틀 엔디안(Little-endian)
- 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터.

ex) 16진수 표기 0x12345678
컴퓨터 표기라서 1 byte = 8bit 씩 끊어서 표시
빅 -> 12 34 56 78
리틀 -> 78 56 34 12 
아래 코드로 둘중 무슨 엔디안인지 확인 가능
역시나 little endian이다.
```python
import sys
print(sys.byteorder)
```

## 실수를 표현하는 방법
컴퓨터는 floating-point(부동소수점) 방식으로 표현
소수점을 왼쪽에 가장 유효한 숫자 다음으로 고정시키고
밑수의 지수승으로 표현한다.

컴퓨터에서 저장형식은 = (부호비트,지수비트,가수비트) 로 나눈다.
단정도(single,32bit) = 1 / 8 / 23
배정도(double,64bit) = 1/ 11/ 52

가수부(mantissa) = 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현
지수부(exponent) = 실제 소수점의 위치를 지수승으로 표현


단정도 실수에선 지수부를 익세스(excess)표현법으로 값을 반으로 나누어 음수와 양수를 나타냄.(총 256개)
즉 bias가 127이고 실제 지수에 127을 더하고 이진수화 하면 지수부가 된다.
소수점 이하는 가수부로 넘기고 나머지 빈 뒷자리는 0으로 채운다.
진짜 소수인 부분은 2진수로 최대한 근사하게 계산한 값을 기준으로
지수부, 가수부로 나눈다.
양수 부호는 = 0, 음수는 1

지수가 모두 1이고 가수 모두 0이면 무한대
지수 모두 1이고 가수에 1이 하나라도 있으면 NaN

32bit 실수 유효자릿수 = 6자리
64 는 15자리 
파이썬은 내부적을 더 많은 비트를 활용해서
5.0e-324 ~ 1.8e+308 의 값 표현 가능 